#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#  mayhem/exploit/windows.py
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions are
#  met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following disclaimer
#    in the documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of the project nor the names of its
#    contributors may be used to endorse or promote products derived from
#    this software without specific prior written permission.
#
#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
#  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
#  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
#  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
#  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
#  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

import code
import ctypes
import os
import platform
import sqlite3

from mayhem.proc.windows import flags
from mayhem.proc.windows import process_is_wow64
from mayhem.proc.windows import WindowsProcess
from mayhem.utilities import align_up

class WindowsSyscallFunction(object):
	__slots__ = ('__function', 'name', 'number')
	def __init__(self, function, name, number):
		self.__function = function
		self.name = name
		self.number = number

	def __call__(self, *args):
		return self.__function(self.number, *args)

	def __repr__(self):
		return "<{0} (0x{1:04x}) >".format(self.name, self.number)

class SyscallPrototype(ctypes._CFuncPtr):
	_argtypes_ = []
	_restype_ = ctypes.c_uint32
	_flags_ = ctypes._FUNCFLAG_CDECL

class WindowsSyscallBase(object):
	__name_map = {
		'Windows-7-6.1.7601-SP1': '7 SP1'
	}
	_syscall_db_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'data', 'windows_syscalls.db'))
	_syscall_prototype = ctypes.CFUNCTYPE(ctypes.c_uint32)
	def __init__(self, os_name=None):
		"""
		:param str os_name: The name of the Windows operating system for which to resolve syscall names to numbers.
		"""
		if process_is_wow64():
			raise RuntimeError('python running in WOW64 is not supported')

		self._syscall_db_con = None
		if os_name is None:
			os_name = self.__name_map.get(platform.platform())
		if os_name is not None:
			self._syscall_db_con = sqlite3.connect(self._syscall_db_path, check_same_thread=False)
			if not self._syscall_db_con.execute('SELECT COUNT(os_name) FROM syscalls WHERE arch = ? AND os_name = ?', (self._syscall_arch, os_name,)).fetchone()[0]:
				raise ValueError('no syscall numbers available in the database for ' + os_name)
		self.os_name = os_name

		process_h = WindowsProcess(pid=-1)
		shellcode_sz = align_up(len(self._syscall_stub), 1024)
		self.address = process_h.allocate(size=shellcode_sz)
		process_h.write_memory(self.address, self._syscall_stub)
		process_h.protect(self.address, size=shellcode_sz, permissions='PAGE_EXECUTE_READ')
		self._syscall = self._syscall_prototype(self.address)

	def __call__(self, syscall, *args):
		if isinstance(syscall, str):
			syscall_number = self.lookup(syscall)
			if syscall_number is None:
				raise LookupError('failed to look up the specified syscall')
		elif isinstance(syscall, int):
			syscall_number = syscall
		else:
			raise TypeError('argument 1 must be str or int')
		return self._syscall(syscall_number, *args)

	def __getattr__(self, syscall_name):
		syscall_number = self.lookup(syscall_name)
		if syscall_number is None:
			raise LookupError('failed to look up the specified syscall')
		return WindowsSyscallFunction(self._syscall, syscall_name, syscall_number)

	def __repr__(self):
		return "<{0} address=0x{1:08x} os_name='{2}' >".format(self.__class__.__name__, self.address, self.os_name)

	def lookup(self, syscall_name):
		"""
		Lookup the number for a syscall by it's name.

		:param str syscall_name: The name of the syscall to lookup.
		:return: The syscall's number specific to the environment.
		:rtype: int
		"""
		if not self._syscall_db_con:
			raise AttributeError('no syscall database is connected')
		cur = self._syscall_db_con.execute(
			'SELECT number FROM syscalls WHERE name = ? AND arch = ? AND os_name = ?',
			(syscall_name, self._syscall_arch, self.os_name)
		)
		result = cur.fetchone()
		if result:
			result = result[0]
		return result

class WindowsX64Syscall(WindowsSyscallBase):
	_syscall_arch = 'x64'
	_syscall_stub = b'\x48\x89\xc8'           # mov rax,rcx
	_syscall_stub += b'\x48\x89\xd1'          # mov rcx,rdx
	_syscall_stub += b'\x4c\x89\xc2'          # mov rdx,r8
	_syscall_stub += b'\x4d\x89\xc8'          # mov r8,r9
	_syscall_stub += b'\x4c\x8b\x4c\x24\x28'  # mov r9,QWORD PTR [rsp+0x28]
	_syscall_stub += b'\x83\xc4\x38'          # add esp,0x38
	_syscall_stub += b'\x49\x89\xca'          # mov r10,rcx
	_syscall_stub += b'\x0f\x05'              # syscall
	_syscall_stub += b'\x83\xec\x38'          # sub esp,0x38
	_syscall_stub += b'\xc3'                  # ret

class WindowsX86Syscall(WindowsSyscallBase):
	_syscall_arch = 'x86'
	_syscall_stub = b'\x5a'                   # pop   edx ; ret -> edx
	_syscall_stub += b'\x58'                  # pop   eax ; arg0 -> eax
	_syscall_stub += b'\x6a\x00'              # push  0
	_syscall_stub += b'\x50'                  # push  eax
	_syscall_stub += b'\x52'                  # push  edx
	_syscall_stub += b'\x83\xc4\x08'          # add   esp,0x8
	_syscall_stub += b'\xba\x00\x03\xfe\x7f'  # mov   edx,0x7ffe0300
	_syscall_stub += b'\xff\x12'              # call  DWORD PTR [edx]
	_syscall_stub += b'\x83\xec\x08'          # sub   esp,0xc8
	_syscall_stub += b'\x5a'                  # pop   edx ; ret -> edx
	_syscall_stub += b'\x83\xc4\x04'          # add   esp,0x4
	_syscall_stub += b'\x52'                  # push  edx
	_syscall_stub += b'\xc3'                  # ret

if platform.architecture()[0] == '64bit':
	_WindowsSyscall = WindowsX64Syscall
else:
	_WindowsSyscall = WindowsX86Syscall

class WindowsSyscall(_WindowsSyscall):
	"""
	An object which facilitates the dynamic execution of raw syscalls though an
	assembly stub. This allows syscalls to be executed like other functions
	using the Python ctypes library.

	Example Usage:

	.. code-block:: python

	  # initialize the object for Windows 7 SP1
	  syscall = WindowsSyscall('7 SP1')
	  syscall.NtQuerySystemInformation(5, 0x010000, 1024**2, None)
	"""
	pass

def allocate_null_page(size=0x1000):
	if platform.architecture()[0] == '64bit':
		address = ctypes.c_uint64()
		size = ctypes.c_uint64()
	else:
		address = ctypes.c_uint32()
		page_size = ctypes.c_uint32()
	address.value = 1
	page_size.value = size
	result = ctypes.windll.ntdll.NtAllocateVirtualMemory(
		-1,
		ctypes.byref(address),
		0,
		ctypes.byref(page_size),
		flags('MEM_RESERVE | MEM_COMMIT | MEM_TOP_DOWN'),
		flags('PAGE_EXECUTE_READWRITE')
	)
	return result == 0

def find_driver_base(driver=None):
	"""
	Get the base address of the specified driver or the NT Kernel if none is
	specified.

	:param str driver: The name of the driver to get the base address of.
	:return: The base address and the driver name.
	:rtype: tuple
	"""
	if platform.architecture()[0] == '64bit':
		lpImageBase = (ctypes.c_ulonglong * 1024)()
		lpcbNeeded = ctypes.c_longlong()
		ctypes.windll.psapi.GetDeviceDriverBaseNameA.argtypes = [ctypes.c_longlong, ctypes.POINTER(ctypes.c_char), ctypes.c_uint32]
	else:
		if process_is_wow64():
			raise RuntimeError('python running in WOW64 is not supported')
		lpImageBase = (ctypes.c_ulong * 1024)()
		lpcbNeeded = ctypes.c_long()
	driver_name_size = ctypes.c_long()
	driver_name_size.value = 48
	ctypes.windll.psapi.EnumDeviceDrivers(ctypes.byref(lpImageBase), ctypes.c_int(1024), ctypes.byref(lpcbNeeded))
	for base_addr in lpImageBase:
		driver_name = ctypes.c_char_p('\x00' * driver_name_size.value)
		if base_addr:
			ctypes.windll.psapi.GetDeviceDriverBaseNameA(base_addr, driver_name, driver_name_size.value)
			if driver is None and driver_name.value.lower().find("krnl") != -1:
				return (base_addr, driver_name.value)
			elif driver_name.value.lower() == driver:
				return (base_addr, driver_name.value)
	return None

def get_haldispatchtable():
	"""
	Get the address of the halDispatchTable.

	:return: The address of the halDispatchTable.
	:rtype: int
	"""
	if platform.architecture()[0] == '64bit':
		ctypes.windll.kernel32.LoadLibraryExA.restype = ctypes.c_uint64
		ctypes.windll.kernel32.GetProcAddress.argtypes = [ctypes.c_uint64, ctypes.POINTER(ctypes.c_char)]
		ctypes.windll.kernel32.GetProcAddress.restype = ctypes.c_uint64
	elif process_is_wow64():
		raise RuntimeError('python running in WOW64 is not supported')
	(krnlbase, kernelver) = find_driver_base()
	hKernel = ctypes.windll.kernel32.LoadLibraryExA(kernelver, 0, 1)
	halDispatchTable = ctypes.windll.kernel32.GetProcAddress(hKernel, 'HalDispatchTable')
	halDispatchTable -= hKernel
	halDispatchTable += krnlbase
	return halDispatchTable

def interact(banner=None, local=None):
	new_local = {
		'ctypes': ctypes,
		'gdi32': ctypes.windll.gdi32,
		'kernel32': ctypes.windll.kernel32,
		'ntdll': ctypes.windll.ntdll,
		'user32': ctypes.windll.user32,
		'WindowsProcess': 'WindowsProcess'
	}
	if local is not None:
		new_local.update(local)

	code.interact(banner=banner, local=new_local)
